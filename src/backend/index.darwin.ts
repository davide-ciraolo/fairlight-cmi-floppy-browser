import { app, BrowserWindow, dialog, ipcMain, Menu, nativeImage } from 'electron';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

import path from 'path';
import * as fs from 'fs';
import * as tmp from 'tmp';
tmp.setGracefulCleanup();
import { deleteFiles, exportFiles, importFiles, openFileDialog, renameFile, saveFloppy, setNewLabel } from './cmifs';
import CmiFile from '../../lib/cmios9/src/CmiFile';
import CmiDirectory from '../../lib/cmios9/src/CmiDirectory';
import cmios9 from '../../lib/cmios9/src/cmios9';

const APP_NAME: string = 'Fairlight CMI2x Floppy Browser';
const APP_ICON: string = process.env.NODE_ENV === 'development' ? path.join(process.cwd(), 'images/icon/icon.icns') : path.join(process.resourcesPath, 'icon.ico');
const FILE_DROP_IMG: string = process.env.NODE_ENV === 'development' ? path.join(process.cwd(), 'images/assets/file48.png') : path.join(process.resourcesPath, 'assets/file48.png');
let currentFileToOpen: string = undefined;
//const tmpDir: string = tmp.dirSync().name;
//let currentCmiDirectory: CmiDirectory = undefined;

interface WindowParams {
  tmpDir: string;
  currentCmiDirectory: CmiDirectory;
  window: BrowserWindow;
  fileToOpen?: string;
}

const appWindows: Set<WindowParams> = new Set();

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = async () => {

  let x, y;
  const currentWindow = BrowserWindow.getFocusedWindow();
  if (currentWindow) {
    const [currentWindowX, currentWindowY] = currentWindow.getPosition();
    x = currentWindowX + 24;
    y = currentWindowY + 24;
  }

  const currentAppWindow: WindowParams = {
    tmpDir:tmp.dirSync().name,
    currentCmiDirectory: undefined,
    fileToOpen: currentFileToOpen,
    window: new BrowserWindow({
      height: 600,
      width: 800,
      x: x,
      y: y,
      title: APP_NAME,
      icon: APP_ICON,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        contextIsolation: true,
        nodeIntegration: false,
      },
      show: false
    })
  };

  // Create the browser window.
  appWindows.add(
    currentAppWindow
  );

  currentAppWindow.window.on('ready-to-show', () => {
    currentAppWindow.window.show();
  });

  // Create application menu
  const menu = Menu.buildFromTemplate([
    {
      label: 'File',
      submenu: [
        {
          id: 'load',
          label: 'Load',
          click: async () => {
            const IMGdir: CmiDirectory | undefined = await openFileDialog();
            if(IMGdir) {
              currentAppWindow.window?.webContents.send('IMG-start-loading');
              IMGdir.loadFiles().then((files: CmiFile[]) => {
                currentAppWindow.window?.webContents.send('IMG-loaded', IMGdir);
                currentAppWindow.currentCmiDirectory = IMGdir;
                menu.getMenuItemById('import-files').enabled = true;
              }).catch((reason) => {
                currentAppWindow.window?.webContents.send('IMG-loading-error', reason + '');
              })
            }
          },
        },
        {
          id: 'import-files',
          label: 'Import Files',
          enabled: currentAppWindow.currentCmiDirectory != undefined,
          click: async () => {
            menu.getMenuItemById('import-files').enabled = false;
            const ret: boolean = await importFiles(currentAppWindow.currentCmiDirectory.imgPath);
            if(ret) {
              const IMGdir: CmiDirectory = await cmios9.reloadDirectory(currentAppWindow.currentCmiDirectory);
              currentAppWindow.window?.webContents.send('IMG-start-loading');
              IMGdir.loadFiles().then((files: CmiFile[]) => {
                currentAppWindow.window?.webContents.send('IMG-loaded', IMGdir);
                currentAppWindow.window?.webContents.send('imported-files', IMGdir);
                currentAppWindow.currentCmiDirectory = IMGdir;
                menu.getMenuItemById('import-files').enabled = true;
              }).catch((reason) => {
                currentAppWindow.window?.webContents.send('IMG-loading-error', reason + '');
                menu.getMenuItemById('import-files').enabled = true;
              });
            } else {
              dialog.showErrorBox('Error importing files', 'An error occoured while importing files.');
              menu.getMenuItemById('import-files').enabled = true;
            }
          },
        },
        { role: 'quit' }, // Adds "Quit" option
      ],
    },
  ]);

  Menu.setApplicationMenu(menu);

  ipcMain.on('dropped-file', async (event, files) => {
    let filePaths: string[] = [];
    for (const f of files) {
      if(f.path.startsWith(currentAppWindow.window))
        console.log('File from application!');
      else
        filePaths.push(f.path);
    }
  
    if(filePaths.length > 0) {
      menu.getMenuItemById('import-files').enabled = false;
      const ret: boolean = await importFiles(currentAppWindow.currentCmiDirectory.imgPath, filePaths);
      if(ret) {
        const IMGdir: CmiDirectory = await cmios9.reloadDirectory(currentAppWindow.currentCmiDirectory);
        currentAppWindow.window?.webContents.send('IMG-start-loading');
        IMGdir.loadFiles().then((files: CmiFile[]) => {
          currentAppWindow.window?.webContents.send('IMG-loaded', IMGdir);
          currentAppWindow.window?.webContents.send('imported-files', IMGdir);
          currentAppWindow.currentCmiDirectory = IMGdir;
          menu.getMenuItemById('import-files').enabled = true;
        }).catch((reason) => {
          currentAppWindow.window?.webContents.send('IMG-loading-error', reason + '');
          menu.getMenuItemById('import-files').enabled = true;
        });
        console.log('Dropped File(s):', files);
        event.returnValue = `Received ${files.length} paths.`; // Synchronous reply
      } else {
        dialog.showErrorBox('Error importing files', 'An error occoured while importing files.');
        event.returnValue = `Error importing ${files.length} files.`; // Synchronous reply
        menu.getMenuItemById('import-files').enabled = true;
      }
      return ret;
    }

    event.returnValue = `No files to import.`; // Synchronous reply
    return true;
  });
  

  ipcMain.on('export-files', async (_, files: CmiFile[]) => {
    return await exportFiles(files);
  });

  ipcMain.on('save-IMD', async (_, dir: CmiDirectory) => {
    currentAppWindow.window?.webContents.send('IMG-start-loading');
    const ret: boolean = await saveFloppy(dir);
    currentAppWindow.window?.webContents.send('IMG-loading-error', '');
    return ret;
  });

  ipcMain.on('new-label', async (_, dir: CmiDirectory) => {
    currentAppWindow.window?.webContents.send('IMG-start-loading');
    const ret: boolean = await setNewLabel(dir);
    currentAppWindow.window?.webContents.send('IMG-loading-error', '');
    return ret;
  });

  ipcMain.on('rename-file', async (_, file: CmiFile, new_fullfilename: string) => {
    currentAppWindow.window?.webContents.send('IMG-start-loading');
    const ret: boolean = await renameFile(file, new_fullfilename);
    currentAppWindow.window?.webContents.send('IMG-loading-error', '');
    return ret;
  });

  ipcMain.on('delete-files', async (_, files: CmiFile[]) => {
    const ret: boolean = await deleteFiles(files);
    if(ret)
      currentAppWindow.window?.webContents.send('deleted-files', files);
    return ret;
  });

  ipcMain.on('ondragstart', (event: any, files: CmiFile[]) => {
    for (const f of files) {
      let tmpfileName: string = path.join(currentAppWindow.tmpDir, f.fullname);
      if (fs.existsSync(tmpfileName))
        fs.rmSync(tmpfileName);
      fs.writeFile(tmpfileName, new Uint8Array(atob(f.fullContentBase64).split('').map(char => char.charCodeAt(0))), () => {
          event.sender.startDrag({
            file: tmpfileName,
            icon: FILE_DROP_IMG
          });
      });
      console.log(`File ${f.fullname} dragged!`);
    }
  });

  // and load the index.html of the app.
  currentAppWindow.window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // If app was opened with a file, open the file.
  if(currentAppWindow.fileToOpen) {
    currentFileToOpen = undefined;

    const ext: string = path.extname(currentAppWindow.fileToOpen).toLowerCase();
    console.log(currentAppWindow.fileToOpen, ext);
    if(ext == '.img' || ext == '.imd' || ext == '.hfe') {
      //open, read, handle file
      const IMGdir: CmiDirectory = await cmios9.getDirectory(currentAppWindow.fileToOpen);
      currentAppWindow.window?.webContents.send('IMG-start-loading');
      IMGdir.loadFiles().then((files: CmiFile[]) => {
        currentAppWindow.window?.webContents.send('IMG-loaded', IMGdir);
        currentAppWindow.currentCmiDirectory = IMGdir;
        menu.getMenuItemById('import-files').enabled = true;
      }).catch((reason) => {
        currentAppWindow.window?.webContents.send('IMG-loading-error', reason + '');
      });
    } else
      dialog.showErrorBox('Error not supported', 'The selected file is not supported by the application.');

  }

};

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  // if (BrowserWindow.getAllWindows().length === 0) {
  //   createWindow();
  // }
  if (BrowserWindow.getAllWindows().length === 0) createWindow();
});

app.on('open-file', async (event: Electron.Event, filePath: string) => {
  currentFileToOpen = filePath;
  createWindow();
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

if (process.arch === 'x64') {
	app.disableHardwareAcceleration();
}

app.dock.setIcon(nativeImage.createFromPath(APP_ICON));

const dockMenu = Menu.buildFromTemplate([
  {
    label: 'New Window',
    click: () => createWindow,
    accelerator: 'Shift+Ctrl+N'
  }
])

app.dock.setMenu(dockMenu);

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
